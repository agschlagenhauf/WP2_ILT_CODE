---
title: "Acces PH withC Model Results"
author: "Milena Musial"
output: html_document
date: '2023-09-24'
format: 
  html:
    embed-resources: true
    toc: true
    toc-depth: 3
    code-fold: true
    number-sections: true
    fig-width: 8
    fig-height: 6
    fig-format: svg
    editor_options: 
    chunk_output_type: console
---

# Setup
```{r}
###### define sample #####

rm(list=ls())

sample <- "n56_hc_alc" # n71, n53, n50
```

```{r}
libs<-c("rstan", "gdata", "bayesplot", "stringr", "dplyr", "ggplot2", "loo", "posterior", "reliabilitydiag")
sapply(libs, require, character.only=TRUE)

datapath <- '/fast/work/groups/ag_schlagenhauf/B01_FP1_WP2/ILT_Stan_Modeling'
out_path <- '/fast/work/groups/ag_schlagenhauf/B01_FP1_WP2/ILT_Stan_Modeling/Output'
behavpath <- '/fast/work/groups/ag_schlagenhauf/B01_FP1_WP2/ILT_DATA'

fit_file <- 'fit_n56_hc_alc_2024-02-25_bandit2arm_delta_PH_withC_DU_fixgamma_init05_estimation1_delta0.99_stepsize0.1.rds'

fit <- readRDS(file.path(out_path, fit_file)) # Stan model output

if (sample == 'n71') {
  load(file.path(behavpath,"Behav/behav_final_redcap_n71.RData")) # Behav and redcap data
  load(file.path(behavpath,"RedCap/redcap_n71.RData")) # redcap data
  input<-read.table(file.path(behavpath, 'Input/Stan_input_n71.txt'), header = T)
  load(file.path(behavpath,"Input/stan_data_bandit2arm_delta_PH_withC_n71.RData"))
} else if (sample == 'n63') {
  load(file.path(behavpath,"Behav/behav_final_redcap_n63.RData")) # Behav and redcap data
  load(file.path(behavpath,"RedCap/redcap_n63.RData")) # redcap data
  input<-read.table(file.path(behavpath, 'Input/Stan_input_n63.txt'), header = T)
  load(file.path(behavpath,"Input/stan_data_bandit2arm_delta_PH_withC_n63.RData"))
} else if (sample == 'n60') {
  load(file.path(behavpath,"Behav/behav_final_redcap_n60.RData")) # Behav and redcap data
  load(file.path(behavpath,"RedCap/redcap_n60.RData")) # redcap data
  input<-read.table(file.path(behavpath, 'Input/Stan_input_n60.txt'), header = T)
  load(file.path(behavpath,"Input/stan_data_bandit2arm_delta_PH_withC_n60.RData"))
} else if (sample == 'n56') {
  load(file.path(behavpath,"Behav/behav_final_redcap_n56.RData")) # Behav and redcap data
  load(file.path(behavpath,"RedCap/redcap_n56.RData")) # redcap data
  input<-read.table(file.path(behavpath, 'Input/Stan_input_n56.txt'), header = T)
  load(file.path(behavpath,"Input/stan_data_bandit2arm_delta_PH_withC_n56.RData"))
} else if (sample == 'n53') {
  load(file.path(behavpath,"Behav/behav_final_redcap_n53.RData")) # Behav and redcap data
  load(file.path(behavpath,"RedCap/redcap_n53.RData")) # redcap data
  input<-read.table(file.path(behavpath, 'Input/Stan_input_n53.txt'), header = T)
  load(file.path(behavpath,"Input/stan_data_bandit2arm_delta_PH_withC_n53.RData"))
} else if (sample == 'n50') {
  load(file.path(behavpath,"Behav/behav_final_redcap_n50.RData")) # Behav and redcap data
  load(file.path(behavpath,"RedCap/redcap_n50.RData")) # redcap data
  input<-read.table(file.path(behavpath, 'Input/Stan_input_n50.txt'), header = T)
  load(file.path(behavpath,"Input/stan_data_bandit2arm_delta_PH_withC_n50.RData"))
} else if (sample == 'n56_aud') {
  load(file.path(behavpath,"Behav/behav_final_redcap_n56.RData")) # Behav and redcap data
  behav_final_redcap <- behav_final_redcap[behav_final_redcap$aud_group=='AUD',]
  load(file.path(behavpath,"RedCap/redcap_n56.RData")) # redcap data
  redcap <- redcap[redcap$aud_group=='AUD',]
  input<-read.table(file.path(behavpath, 'Input/Stan_input_aud_n56.txt'), header = T)
  load(file.path(behavpath,"Input/stan_data_bandit2arm_delta_PH_withC_n56_aud.RData"))
} else if (sample == 'n56_hc') {
  load(file.path(behavpath,"Behav/behav_final_redcap_n56.RData")) # Behav and redcap data
  behav_final_redcap <- behav_final_redcap[behav_final_redcap$aud_group=='HC',]
  load(file.path(behavpath,"RedCap/redcap_n56.RData")) # redcap data
  redcap <- redcap[redcap$aud_group=='HC',]
  input<-read.table(file.path(behavpath, 'Input/Stan_input_hc_n56.txt'), header = T)
  load(file.path(behavpath,"Input/stan_data_bandit2arm_delta_PH_withC_n56_hc.RData"))
} else if (sample == 'n56_aud_alc') {
  load(file.path(behavpath,"Behav/behav_final_redcap_n56.RData")) # Behav and redcap data
  behav_final_redcap <- behav_final_redcap[behav_final_redcap$aud_group=='AUD'&behav_final_redcap$reinforcer_type=='A',]
  load(file.path(behavpath,"RedCap/redcap_n56.RData")) # redcap data
  redcap <- redcap[redcap$aud_group=='AUD'&redcap$reinforcer_type=='A',]
  input<-read.table(file.path(behavpath, 'Input/Stan_input_alc_aud_n56.txt'), header = T)
  load(file.path(behavpath,"Input/stan_data_bandit2arm_delta_PH_withC_n56_aud_alc.RData"))
} else if (sample == 'n56_hc_alc') {
  load(file.path(behavpath,"Behav/behav_final_redcap_n56.RData")) # Behav and redcap data
  behav_final_redcap <- behav_final_redcap[behav_final_redcap$aud_group=='HC'&behav_final_redcap$reinforcer_type=='A',]
  load(file.path(behavpath,"RedCap/redcap_n56.RData")) # redcap data
  redcap <- redcap[redcap$aud_group=='HC'&redcap$reinforcer_type=='A',]
  input<-read.table(file.path(behavpath, 'Input/Stan_input_alc_hc_n56.txt'), header = T)
  load(file.path(behavpath,"Input/stan_data_bandit2arm_delta_PH_withC_n56_hc_alc.RData"))
} else if (sample == 'n56_aud_jui') {
  load(file.path(behavpath,"Behav/behav_final_redcap_n56.RData")) # Behav and redcap data
  behav_final_redcap <- behav_final_redcap[behav_final_redcap$aud_group=='AUD'&behav_final_redcap$reinforcer_type=='J',]
  load(file.path(behavpath,"RedCap/redcap_n56.RData")) # redcap data
  redcap <- redcap[redcap$aud_group=='AUD'&redcap$reinforcer_type=='J',]
  input<-read.table(file.path(behavpath, 'Input/Stan_input_jui_aud_n56.txt'), header = T)
  load(file.path(behavpath,"Input/stan_data_bandit2arm_delta_PH_withC_n56_aud_jui.RData"))
} else if (sample == 'n56_hc_jui') {
  load(file.path(behavpath,"Behav/behav_final_redcap_n56.RData")) # Behav and redcap data
  behav_final_redcap <- behav_final_redcap[behav_final_redcap$aud_group=='HC'&behav_final_redcap$reinforcer_type=='J',]
  load(file.path(behavpath,"RedCap/redcap_n56.RData")) # redcap data
  redcap <- redcap[redcap$aud_group=='HC'&redcap$reinforcer_type=='J',]
  input<-read.table(file.path(behavpath, 'Input/Stan_input_jui_hc_n56.txt'), header = T)
  load(file.path(behavpath,"Input/stan_data_bandit2arm_delta_PH_withC_n56_hc_jui.RData"))
}

color_scheme_set("mix-blue-pink")
```

Load data from prior predictive checks (estimation==0) or from model fitting (estimation==1)?
```{r}
estimation <- 1
```

# Convergence / sampler diagnostics

## Summary statistics for parameters

### Across chains

```{r}
fit_sum <- summary(fit)

# overall summary
print(fit_sum$summary[,9:10])
```

-   All `Rhat` values are \< 1.01, meaning that chains have converged! \`

-   All `n_eff` (measure of the effective sample size) are \> 1/100th (360) or 1/1000th (36) of number of iterations (3600). Anything over an `n_eff` of 100 is usually "fine"

## Bulk effective sample size

```{r}
if (estimation==1) {
  # extract posterior draws
  posterior_mat <- extract(fit, permuted = F)
  
  # define parameter names
  parameter_names <- c("mu_pr[1]", "mu_A", "sigma[1]", "A_pr[20]", "A[20]",
                       "mu_pr[2]", "mu_tau", "sigma[2]", "tau_pr[20]", "tau[20]",
                       "mu_pr[3]", "mu_C", "sigma[3]", "C_pr[20]", "C[20]")
  
  # create vector for bulk ess and fill them up iteratively
  bulk_neff <- c()
  
  for (par in parameter_names) {
    par_mat <- extract_variable_matrix(posterior_mat, variable = par)
    bulk_neff <- append(bulk_neff,ess_bulk(par_mat))
  }
  
  print(min(bulk_neff))
  ess_df <- data.frame(parameter_names,bulk_neff)
  print(ess_df)
  
}
```

## Traceplots of model parameters

```{r}
traceplot(fit, pars=c("mu_pr[1]", "mu_A", "sigma[1]", "A_pr[20]", "A[20]"), inc_warmup=T)

traceplot(fit, pars=c("mu_pr[2]", "mu_tau", "sigma[2]", "tau_pr[20]", "tau[20]"),inc_warmup=T)

traceplot(fit, pars=c("mu_pr[3]", "mu_C", "sigma[3]", "C_pr[20]", "C[20]"),inc_warmup=T)
```

## Acceptance rate and tree depth per chain

```{r}
sampler_params<- get_sampler_params(fit, inc_warmup=FALSE)

mean_accept_stat_by_chain<-sapply(sampler_params, function(x) mean(x[, "accept_stat__"]))
print(mean_accept_stat_by_chain)

max_treedepth_by_chain <- sapply(sampler_params, function(x) max(x[, "treedepth__"]))
print(max_treedepth_by_chain)
```

# Model fit (Log Likelihood)

```{r}
if (estimation==1) {
  # extract log likelihood for each choice
  log_likelihood <- extract_log_lik(fit, parameter_name = "log_lik", merge_chains = TRUE)
  
  # create logical vector coding if a column should be included in log_likelihood
  x <- logical(stan_data$T) # create vector containing total number of trials * FALSE
  a <- c(stan_data$N+1:(stan_data$N*49)) # vector with number from 1 to 71 subjects * 44 trials (for cond. 1)
  x[a] <- TRUE # set logical value to TRUE if index in c
  
  # exclude 1st trial per subject as likelihood is identical and hinders loo estimation (causes Inf pareto k values)
  log_likelihood <- log_likelihood[,x] # include only trials 1:44 for each subject and reinforcer_type

  # exclude missing trials
  log_likelihood <- log_likelihood[,log_likelihood[1,]!=-999]

  # save for model comparison
  write.table(log_likelihood, file=file.path(out_path, 'log_lik_PH_withC.txt'), append = FALSE, sep = " ", dec = ".", row.names = F, col.names = F)
  
  # print and plot loo
  loo1 <- loo(log_likelihood)
  print(loo1)
  plot(loo1, label_points = TRUE)
  
  waic1 <- waic(log_likelihood)
  print(waic1)
}
```

## Per block and subject 

```{r}
if (estimation==1) {
  # extract log likelihood for each choice
  log_likelihood_s <- extract_log_lik(fit, parameter_name = "log_lik_s", merge_chains = TRUE)
  
  # save for model comparison
  # write.table(log_likelihood, file=file.path(out_path, 'log_lik_s_PH_withC_hierarchical.txt'), append = FALSE, sep = " ", dec = ".", row.names = F, col.names = F)

  # print and plot loo
  loo3 <- loo(log_likelihood_s)
  print(loo3)
  plot(loo3, label_points = TRUE)
  
  waic3 <- waic(log_likelihood_s)
  print(waic3)
}
```

# Inspect posteriors

## Posterior densities & histograms

```{r}
stan_hist(fit, pars=c("mu_pr[1]", "mu_A", "sigma[1]", "A_pr[20]", "A[20]",
                       "mu_pr[2]", "mu_tau", "sigma[2]", "tau_pr[20]", "tau[20]",
                       "mu_pr[3]", "mu_C", "sigma[3]", "C_pr[20]", "C[20]"))
```

## Mean parameter estimates and credible intervals

```{r}
plot(fit, pars=c("mu_pr[1]", "mu_A", "sigma[1]", "A_pr[20]", "A[20]",
                       "mu_pr[2]", "mu_tau", "sigma[2]", "tau_pr[20]", "tau[20]",
                       "mu_pr[3]", "mu_C", "sigma[3]", "C_pr[20]", "C[20]"), 
     show_density = FALSE, ci_level = 0.5, outer_level = 0.95, fill_color = "salmon")
```

## Probability that each parameter is over / under a certain value of interest

```{r}
posterior_list <- extract(fit, permuted = T)

sum(posterior_list$A>0.5)/length(posterior_list$A)
sum(posterior_list$tau>50)/length(posterior_list$tau)
sum(posterior_list$C>0.5)/length(posterior_list$C)
```

# Prior / Posterior predictive checks

## Load real subject data (input for Stan)

```{r}
choice <- stan_data[["choice"]]

# only select trials in which all subjects made a choice
choice <- c(choice[,1:44])
```

## Extract simulated values from generated quantities block

```{r}
y_pred <- as.matrix(fit, pars = "y_pred")

# create logical vector coding if a column should be included in y_pred
x <- logical(stan_data$T)
a <- c(1:(stan_data$N*44))
x[a] <- TRUE

# exclude 48:50th trial per subject
y_pred <- y_pred[,x]
y_pred_m <- colMeans(y_pred)
```

## Calibration / reliability plot

```{r}
rd <- reliabilitydiag(EMOS = y_pred_m, y = choice)
                      
autoplot(rd) +
  labs(x="Predicted (LOO)",
       y="Conditional event probabilities") +
  bayesplot::theme_default(base_family = "sans", base_size=16)
```

## Compare estimates of summary statistics between choice and predicted choice

```{r}
ppc_stat(y = choice, yrep = y_pred, stat = function(y) mean(y, na.rm=T))
```

## Bar plot: count of choices and estimated choices

```{r}
ppc_bars(y = choice, yrep = y_pred)
```

## Trial-by-trial plotting of real and simulated choices

### Prepare data
```{r}
# real data
choice_df <- as.data.frame(choice)
names(choice_df)[1] <- "choice"
choice_df$ID <- rep(unique(input$subjID), times=44)
choice_df$trial <- rep(c(1:44),each = stan_data$N)

# simulated data
y_pred_df <- as.data.frame(t(y_pred)) # create df containing all iterations seperately
names <- c(seq(1,36000))
colnames(y_pred_df) <- names
 
y_pred_mean <- summary(fit, pars = "y_pred")$summary[, c("mean")] # create vector containing mean across all iterations

y_pred_mean_summary <- t(matrix(y_pred_mean, nrow = 50)) # subject * trial matrix
y_pred_mean_summary <- y_pred_mean_summary[,1:44] # exclude NA trials

y_pred_df$mean <- c(y_pred_mean_summary) # combine mean with df containing all iterations seperately

y_pred_sd <- summary(fit, pars = "y_pred")$summary[, c("sd")] # create vector containing sd across all iterations

y_pred_sd_summary <- t(matrix(y_pred_sd, nrow = 50)) # subject * trial matrix
y_pred_sd_summary <- y_pred_sd_summary[,1:44] # exclude NA trials

y_pred_df$sd <- c(y_pred_sd_summary) # combine mean with df containing all iterations seperately

# combine dfs
choice_y_pred_df <- cbind(choice_df,y_pred_df)

# get p correct per trial for plotting
choice_y_pred_df_trial <- choice_y_pred_df %>%
  group_by(trial) %>%
  summarise_at(vars(choice,mean,sd), list(p_correct = mean), na.rm=T)
```

### Plot across AUD group and reinforcer type
```{r}
fig1 <- ggplot(choice_y_pred_df_trial, aes(x=trial)) +
  geom_line(aes(x=trial, y=mean_p_correct, colour = "mean_p_correct")) +
  geom_line(aes(x=trial, y=choice_p_correct, colour = "choice_p_correct")) +
  geom_ribbon(aes(x=trial, y=mean_p_correct, ymin = mean_p_correct - sd_p_correct, ymax = mean_p_correct + sd_p_correct), fill = "#0072B2", alpha = .2) +
  ylab('% correct') +
  theme_bw(base_size=12)

fig1
```

# Extract parameter estimates

## Alpha per subject

```{r}
# mean across iterations of all chains
A_summary <- as.matrix(summary(fit, pars = "A")$summary[, c("mean")]) 
```

## Inverse temperature per subject

```{r}
# mean across iterations of all chains
tau_summary <- as.matrix(summary(fit, pars = "tau")$summary[, c("mean")]) 
```

## C per subject

```{r}
# mean across iterations of all chains
C_summary <- as.matrix(summary(fit, pars = "C")$summary[, c("mean")]) 
```

## Save parameter estimates together with ID, reinforcer type, aud group information

```{r}
params <- as.data.frame(unique(behav_final_redcap$ID_block))
params$alpha <- A_summary
params$invtemp <- tau_summary
params$C <- C_summary
names(params) <- c("ID_block", "alpha", "tau", "C")

demo_behav <- behav_final_redcap %>%
  mutate(reinforcer_type = factor(reinforcer_type, levels = c("J","A"))) %>%
  group_by(ID,ID_block,aud_group,reinforcer_type,block) %>%
  summarise_at(vars(correct), list(p_correct = mean), na.rm=T)

params <- merge(demo_behav,params,by="ID_block")
params

if (estimation==1) {
  write.table(params, file=file.path(out_path, paste('Params_PH_withC_fixgamma_', sample, '.txt', sep="")), append = FALSE, sep = " ", dec = ".", row.names = F, col.names = T)
}
```

# Trial-by-trial quantities (can be used as fMRI parametric modulators)

## RPEs

### Extract as parametric modulators

```{r}
# mean across iterations of all chains
PE_summary <- as.data.frame(summary(fit, pars = "PE_pred")$summary[, c("mean")])
PE_summary <- PE_summary %>%
  rename(PE_pred = `summary(fit, pars = "PE_pred")$summary[, c("mean")]`) %>%
  mutate_at(c('PE_pred'), ~na_if(., -999))
PE_summary$ID_block <- behav_final_redcap$ID_block
PE_summary$trial_block <- behav_final_redcap$trial_block
PE_summary$ID <- behav_final_redcap$ID
PE_summary$reinforcer_type <- behav_final_redcap$reinforcer_type

if (estimation==1) {
  write.table(PE_summary, file=file.path(out_path, paste('fmri_PEs_PH_withC_fixgamma_', sample, '.txt', sep="")), append = FALSE, sep = " ", dec = ".", row.names = F, col.names = T)
}
```

### Plot over course of trials

```{r}
# across subjects
PE_summary_per_trial <- PE_summary %>%
  group_by(trial_block) %>%
  summarise_at(vars(PE_pred), list(PE_mean = mean), na.rm=T)

fig_PE_per_trial <- ggplot(PE_summary_per_trial, aes(x=trial_block, y=PE_mean)) +
  geom_point() +
  geom_line() +
  theme_bw(base_size=12)

fig_PE_per_trial
```

## Chosen Q

### Extract as parametric modulators

```{r}
# mean across iterations of all chains
Q_summary <- as.data.frame(summary(fit, pars = "ev_chosen_pred")$summary[, c("mean")])
Q_summary <- Q_summary %>%
  rename(Q_pred = `summary(fit, pars = "ev_chosen_pred")$summary[, c("mean")]`) %>%
  mutate_at(c('Q_pred'), ~na_if(., -999))
Q_summary$ID_block <- behav_final_redcap$ID_block
Q_summary$trial_block <- behav_final_redcap$trial_block
Q_summary$ID <- behav_final_redcap$ID
Q_summary$reinforcer_type <- behav_final_redcap$reinforcer_type

if (estimation==1) {
  write.table(Q_summary, file=file.path(out_path, paste('fmri_Qs_PH_withC_fixgamma_', sample, '.txt', sep="")), append = FALSE, sep = " ", dec = ".", row.names = F, col.names = T)
}
```

### Plot over course of trials

Currently trying to plot Q values of better and worse card separately over course of trials.

```{r}
# mean across iterations of all chains
Q_summary <- as.data.frame(summary(fit, pars = "ev_pred")$summary[, c("mean")])

Q_incorr_summary <- as.data.frame(Q_summary[c(TRUE,rep(FALSE,1)), ]) # spilt df into incorrect and correct card
names(Q_incorr_summary) <- "Q_pred"
Q_corr_summary <- as.data.frame(Q_summary[c(rep(FALSE,1),TRUE), ])
names(Q_corr_summary) <- "Q_pred"

Q_incorr_summary$choice <- 'incorrect'
Q_corr_summary$choice <- 'correct'

Q_incorr_summary <- Q_incorr_summary %>%
  mutate_at(c('Q_pred'), ~na_if(., -999))
Q_corr_summary <- Q_corr_summary %>%
  mutate_at(c('Q_pred'), ~na_if(., -999))

Q_incorr_summary$ID_block <- behav_final_redcap$ID_block
Q_corr_summary$ID_block <- behav_final_redcap$ID_block
Q_incorr_summary$trial_block <- behav_final_redcap$trial_block
Q_corr_summary$trial_block <- behav_final_redcap$trial_block
Q_incorr_summary$ID <- behav_final_redcap$ID
Q_corr_summary$ID <- behav_final_redcap$ID
Q_incorr_summary$reinforcer_type <- behav_final_redcap$reinforcer_type
Q_corr_summary$reinforcer_type <- behav_final_redcap$reinforcer_type

Q_summary <- rbind(Q_incorr_summary,Q_corr_summary)

# per choice and trial
Q_summary_per_trial <- Q_summary %>%
  group_by(trial_block,choice) %>%
  summarise_at(vars(Q_pred), list(Q_mean = mean), na.rm=T)

fig_Q_per_trial <- ggplot(Q_summary_per_trial, aes(x=trial_block, y=Q_mean, group=choice)) +
  geom_line(aes(color=choice)) +
  geom_point() +
  theme_bw(base_size=12)

fig_Q_per_trial

# per choice and trial and condition
Q_summary_per_trial_cond <- Q_summary %>%
  group_by(trial_block,choice,reinforcer_type) %>%
  summarise_at(vars(Q_pred), list(Q_mean = mean), na.rm=T)

fig_Q_per_trial_cond <- ggplot(Q_summary_per_trial_cond, aes(x=trial_block, y=Q_mean, group=choice)) +
  geom_line(aes(color=choice)) +
  geom_point() +
  theme_bw(base_size=12) +
  facet_wrap(~reinforcer_type, scales="fixed")

fig_Q_per_trial_cond

```

## Choice probability of chosen option

### Extract as parametric modulators

```{r}
# mean across iterations of all chains
pc_summary <- as.data.frame(summary(fit, pars = "softmax_ev_chosen")$summary[, c("mean")])
pc_summary <- pc_summary %>%
  rename(pc_pred = `summary(fit, pars = "softmax_ev_chosen")$summary[, c("mean")]`) %>%
  mutate_at(c('pc_pred'), ~na_if(., -999))
pc_summary$ID_block <- behav_final_redcap$ID_block
pc_summary$trial_block <- behav_final_redcap$trial_block
pc_summary$ID <- behav_final_redcap$ID
pc_summary$reinforcer_type <- behav_final_redcap$reinforcer_type

if (estimation==1) {
  write.table(pc_summary, file=file.path(out_path, paste('fmri_pcs_PH_withC_fixgamma_', sample, '.txt', sep="")), append = FALSE, sep = " ", dec = ".", row.names = F, col.names = T)
}
```

### Plot over course of trials

```{r}
# across subjects
pc_summary_per_trial <- pc_summary %>%
  group_by(trial_block,reinforcer_type) %>%
  summarise_at(vars(pc_pred), list(pc_mean = mean), na.rm=T)

fig_pc_per_trial <- ggplot(pc_summary_per_trial, aes(x=trial_block, y=pc_mean, group = reinforcer_type)) +
  geom_point() +
  geom_line(aes(color=reinforcer_type)) +
  theme_bw(base_size=12)

fig_pc_per_trial
```
